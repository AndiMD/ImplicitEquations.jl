# ImplicitEquations

The `ImplicitEquations` package implements part of an algorithm due to 
[Tupper](http://www.dgp.toronto.edu/people/mooncake/papers/SIGGRAPH2001_Tupper.pdf)
for graphing two-dimensional implicit equations and
inequalities.

This file provides some examples. It may be viewed as an `IJulia` notebook ([here](http://nbviewer.ipython.org/github/jverzani/ImplicitEquations.jl/blob/master/examples/examples.ipynb)).


Our first example shows how to graph the
[Devils curve](http://www-groups.dcs.st-and.ac.uk/~history/Curves/Devils.html)
over the default region as follows:

```
using PyPlot
pygui(false)
figure(figsize=(5.12, 3.84))
using ImplicitEquations


a,b = -1,2
f(x,y) = y^4 - x^4 + a*y^2 + b*x^2
r = (f==0)
plot(r)
```



The `f == 0` expression above creates a `Predicate` that is graphed by
`plot`. For all but the case of `f==g` (for two functions)
`Predicate`s are generated by overloading the logical operators for
functions on the left and real values or functions on the right: `<`,
`<=` (`\le[tab]`), `\Equal[tab]`, `\lessgtr[tab]`, `>=` (`\ge[tab]`),
and `>` . As `==` and `!=` can already be used to compare functions in
a different way, we use either `eq(f,g)` or `neq(f,g)` for these
comparisons. Should infix notation be preferred, the Unicode operators
`f \Equal[tab] g` or `f \lessgtr[tab] g` may be used.

For example, the
[Trident of Newton](http://www-history.mcs.st-and.ac.uk/Curves/Trident.html)
can be represented in Cartesian form as follows:

```
## trident of Newton
c,d,e,h = 1,1,1,1
f(x,y) = x*y
g(x,y) =c*x^3 + d*x^2 + e*x + h
plot(eq(f,g)) ## aka f ⩵ g (using Unicode\Equal[tab])
```


Inequalities can be graphed as well

```
f(x,y)= (y-5)*cos(4*sqrt((x-4)^2 + y^2))
g(x,y) = x*sin(2*sqrt(x^2 + y^2))
r = f < g
plot(r, -10, 10, -10, 10, W=2^9, H=2^9, show_red=true)  # xmin, xmax, ymin, ymax, pixels_wide, pixels_high
```



The coloring scheme employed (mostly) follows Tupper and is based on pixels:

- if a pixel is white, there are no solutions of the predicate `r` within the
pixel;

- if a pixel is black, there is at least one solution of the predicate `r`
within the pixel;

- if a pixel is red, there may or may not be solutions of the predicate `r` within the pixel. (However, we check these pixels probabilistically and color them black or white.) Red pixels show when the keyword argument `show_red` is assigned to be `true`, as above.

A "pixel" represents a region comprised of two intervals. The excellent `ValidatedNumerics` package is used for the underlying interval arithmetic.

(In the above pixel does not refer to screen pixels for all the graphical outputs, only for a few.)


This static figure shows the algorithm for $f(x,y) = y - \sqrt{x}$:

![Algorithm](http://i.imgur.com/8Mtmb7v.png)

The basic algorithm is to initially break up the graphing region into
square regions. (This uses the number of pixels, which are specified
by `W` and `H` above.)  These regions are checked for the
predicate. If definitely not, the region is painted white; if
definitely yes, the region is painted black; else the square region is
subdivided into 4 smaller regions and the above is repeated until
subdivision would be below the pixel level. At which point, the
remaining 1-by-1 pixels are checked for possible solutions, for
example for equalities where continuity is known a random sample of
points is investigated with the intermediate value theorem.


This example, the
[Batman equation](http://yangkidudel.wordpress.com/2011/08/02/love-and-mathematics/),
uses a few new things: the `screen` function is used to restrict
ranges and logical operators to combine predicates.

```
f0(x,y) = ((x/7)^2 + (y/3)^2 - 1)  *   screen(abs(x)>3) * screen(y > -3*sqrt(33)/7) 
f1(x,y) = ( abs(x/2)-(3 * sqrt(33)-7) * x^2/112 -3 +sqrt(1-(abs((abs(x)-2))-1)^2)-y)
f2(x,y) = y - (9 - 8*abs(x))       *   screen((abs(x)>= 3/4) &  (abs(x) <= 1) )
f3(x,y) = y - (3*abs(x) + 3/4)     *   I_((1/2 < abs(x)) & (abs(x) < 3/4))    # alternate name for screen
f4(x,y) = y - 2.25                 *   I_(abs(x) <= 1/2) 
f5(x,y) = (6 * sqrt(10)/7 + (1.5-.5 * abs(x)) - 6 * sqrt(10)/14 * sqrt(4-(abs(x)-1)^2) -y) * screen(abs(x) >= 1)

r = (f0==0) | (f1==0) | (f2== 0) | (f3==0) | (f4==0) | (f5==0)
plot(r, -7, 7, -4, 4)
```


- predicates can be joined logically with `&`, `|`. Use `!` for negation.

- The `screen` function can be used to restrict values according to
  some predicate call.

- the logical comparisons such as `(abs(x)>= 3/4) & (abs(x) <= 1)`
  within `screen` are not typical in that one can't write
  `3/4 <= abs(x) <= 1`, a convenient `Julian` syntax. This is due to the fact that the "`x`s"
  being evaluated are not numbers, rather intervals via
  `ValidatedNumerics`. For intervals, values may be true, false or
  "maybe" so a different interpretation of the logical operators is
  given that doesn't lend itself to the more convenient notation.

- rendering can be slow. There are two reasons: images that require a
  lot of checking, such as the inequality above, are slow just because
  more regions must be analyzed. As well, some operations are slow,
  such as division, as adjustments for discontinuities are slow. (And
  by slow, it can means really slow. The difference between rendering
  `(1-x^2)*(2-y^2)` and `csc(1-x^2)*cot(2-y^2)` can be 10 times.)

## A "typical" application

A common calculus problem is to find the tangent line using implicit
differentiation. The difficulty here is adding a layer to a graph
produced by `plot(r::Predicate)`. How to do this varies with the
underlying plotting package. Rather than cook up package-specific solutions, we can just use `|`:


```
f(x,y) = x^2 + y^2
a,b = 3,3
dydx(a,b) = -b/a             # implicit differentiate to get dy/dx =-y/x
tl(x) = b + dydx(a,b)*(x-a)

g(x,y) = y - tl(x)

r = (f == f(a,b)) | (g == 0)
plot(r)
```

## Display

The graphs can be rendered in different ways.

* The `asciigraph` function is always available and makes a simple text-based plot:

```
f(x,y) = y - sin(x)
asciigraph(f==0)
```

* When one of several plotting packages are loaded, their `plot`
  function is extended to display a graph when the first argument is a
  `Predicate`, as generated by the expressions above.

- for `Winston`, the function  `ImplicitEquations.wgraph` does the work,

- for `PyPlot`, the function  `ImplicitEquations.pgraph` does the work, and

- for `Gadfly`, the function  `ImplicitEquations.ggraph` does the work. (`Gadfly` must be loaded prior to `ImplicitEquations`.)


This packages use the `Requires.jl` package to conditionally load
modules. In theory the plotting packages can be loaded before or after
`ImplicitEquations`, though in practice that can raise errors, such as
with `Gadfly`.

## Alternatives

Many such plots are simply a single level of a contour plot. Contour plots
can be drawn with the help of the `Contour.jl` package. They are
implemented directly in `Gadfly` and `PyPlot`.

The `SymPy` package exposes SymPy's `plot_implicit` feature that will
implicitly plot a symbolic expression in 2 variables including
inequalities. The algorithm there also follows Tupper and uses
interval arithmetic, as possible.

## TODO

*LOTS*:

* Check out these graphs to see which can be done

- [http://www.xamuel.com/graphs-of-implicit-equations/](http://www.xamuel.com/graphs-of-implicit-equations/)

- [http://www.peda.com/grafeq/gallery.html](http://www.peda.com/grafeq/gallery.html)

* branch cut tracking and interval sets are employed by Tupper, these
  could be added. This would allow some other functions such as `mod`,
  or `±` to be defined.

* Tupper sketches out how to be more rigorous with computing whether a region is black or white.

* increase speed (could color 1-pixel regions better if so, perhaps; division checks; type stability).

